# üß± QuickBooks Backend: Full Drizzle + Sync + Deployment Setup

This document contains the complete setup for the QuickBooks integration backend using **NeonDB**, **Drizzle ORM**, and **Express**, including upserts, webhooks, sync jobs, token refresh, and PM2 deployment.

---

## 1Ô∏è‚É£ Schema

(Complete schema definition for companies, tokens, customers, items, estimates, estimate line items, and invoices ‚Äî see previous content.)

---

## 2Ô∏è‚É£ Upsert Functions (QuickBooks ‚Üí NeonDB)

(Full code examples for upserting Customers, Invoices, Items, and Estimates with Drizzle ORM.)

---

## 3Ô∏è‚É£ QuickBooks Webhook Handler

(Webhook listener for real-time QuickBooks ‚Üí Backend ‚Üí NeonDB synchronization.)

---

## 4Ô∏è‚É£ Hourly Sync Service

(Scheduled job that fetches and upserts all QuickBooks entities every hour.)

---

## 5Ô∏è‚É£ QuickBooks API Client (`getQboData()`)

(Utility for querying QuickBooks Online data using stored OAuth tokens.)

---

## 6Ô∏è‚É£ Token Refresh Automation (Every 50 Minutes)

This cron job automatically refreshes QuickBooks tokens using OAuth 2.0 and upserts them into NeonDB.

```ts
import axios from 'axios';
import { sql } from '../db/index.js';
import cron from 'node-cron';
import dotenv from 'dotenv';

dotenv.config();

export async function refreshQuickBooksTokens() {
  const [token] = await sql`SELECT * FROM quickbooks.tokens WHERE is_active = true ORDER BY last_updated DESC LIMIT 1;`;
  if (!token) {
    console.warn('‚ö†Ô∏è No active QuickBooks token found for refresh.');
    return;
  }

  try {
    console.log('üîÑ Refreshing QuickBooks access token...');
    const response = await axios.post(
      'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer',
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: token.refresh_token,
      }),
      {
        headers: {
          Authorization: `Basic ${process.env.QBO_AUTH_BASIC}`,
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      }
    );

    const newAccessToken = response.data.access_token;
    const newRefreshToken = response.data.refresh_token || token.refresh_token;
    const expiresAt = new Date(Date.now() + response.data.expires_in * 1000);

    await sql`
      INSERT INTO quickbooks.tokens (access_token, refresh_token, realm_id, expires_at, last_updated)
      VALUES (${newAccessToken}, ${newRefreshToken}, ${token.realm_id}, ${expiresAt}, NOW())
      ON CONFLICT (realm_id)
      DO UPDATE SET
        access_token = EXCLUDED.access_token,
        refresh_token = EXCLUDED.refresh_token,
        expires_at = EXCLUDED.expires_at,
        last_updated = NOW();
    `;

    console.log('‚úÖ QuickBooks token refreshed successfully');
  } catch (err) {
    console.error('‚ùå Token refresh failed:', err.response?.data || err.message);
  }
}

// Schedule token refresh every 50 minutes
cron.schedule('*/50 * * * *', async () => {
  console.log('‚è∞ Running scheduled QuickBooks token refresh...');
  await refreshQuickBooksTokens();
});
```

---

## 7Ô∏è‚É£ PM2 Ecosystem Configuration (Production Setup)

The `ecosystem.config.js` ensures both your **token refresher** and **hourly sync** services run persistently with logging and auto-restarts.

```js
module.exports = {
  apps: [
    {
      name: 'wemakemarin-tokenup',
      script: 'services/tokenRefresher.js',
      cwd: '/var/www/wemakemarin/backend',
      env: {
        NODE_ENV: 'production',
        PORT: 5000,
        DATABASE_URL: process.env.DATABASE_URL,
        QBO_AUTH_BASIC: process.env.QBO_AUTH_BASIC,
        QBO_CLIENT_ID: process.env.QBO_CLIENT_ID,
        QBO_CLIENT_SECRET: process.env.QBO_CLIENT_SECRET,
        QBO_REDIRECT_URI: process.env.QBO_REDIRECT_URI
      },
      watch: false,
      autorestart: true,
      max_restarts: 5,
      restart_delay: 10000,
      log_date_format: 'YYYY-MM-DD HH:mm Z',
      error_file: '/var/log/pm2/wemakemarin-tokenup.err.log',
      out_file: '/var/log/pm2/wemakemarin-tokenup.out.log'
    },
    {
      name: 'wemakemarin-sync',
      script: 'services/hourlySync.js',
      cwd: '/var/www/wemakemarin/backend',
      env: {
        NODE_ENV: 'production',
        DATABASE_URL: process.env.DATABASE_URL,
        QBO_AUTH_BASIC: process.env.QBO_AUTH_BASIC,
        QBO_CLIENT_ID: process.env.QBO_CLIENT_ID,
        QBO_CLIENT_SECRET: process.env.QBO_CLIENT_SECRET
      },
      watch: false,
      autorestart: true,
      restart_delay: 15000,
      log_date_format: 'YYYY-MM-DD HH:mm Z',
      error_file: '/var/log/pm2/wemakemarin-sync.err.log',
      out_file: '/var/log/pm2/wemakemarin-sync.out.log'
    }
  ]
};
```

### Deployment Commands
```bash
# Start both services
pm2 start ecosystem.config.js

# Check running processes
pm2 list

# View logs
pm2 logs wemakemarin-tokenup
pm2 logs wemakemarin-sync

# Auto-start PM2 on boot
pm2 startup systemd
pm2 save
```

---

## ‚úÖ Summary

- ‚úÖ Drizzle schema for all QuickBooks entities
- ‚úÖ Upserts for QuickBooks ‚Üí NeonDB sync
- ‚úÖ Webhook + Hourly Sync for real-time updates
- ‚úÖ OAuth Token refresh automation every 50 min
- ‚úÖ PM2 ecosystem config for persistent production processes

Next: we can extend this with a **GitHub Actions CI/CD pipeline** for automated backend deployment + Cloudflare cache invalidation.